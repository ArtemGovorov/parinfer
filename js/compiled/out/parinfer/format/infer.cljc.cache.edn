;; Analyzed by ClojureScript 1.7.122
{:use-macros nil, :excludes #{}, :name parinfer.format.infer, :imports nil, :requires {clojure.string clojure.string, parinfer.format.string parinfer.format.string, parinfer.format.reader parinfer.format.reader}, :uses {whitespace? parinfer.format.reader, insert-string parinfer.format.string, join clojure.string, in-code? parinfer.format.reader, valid-closer? parinfer.format.reader, in-comment? parinfer.format.reader, remove-str-range parinfer.format.string, closing-delim? parinfer.format.reader, in-str? parinfer.format.reader, matching-delim parinfer.format.reader, push-char parinfer.format.reader, get-lines parinfer.format.string, escaping? parinfer.format.reader}, :defs {initial-state {:name parinfer.format.infer/initial-state, :file "src/parinfer/format/infer.cljc", :line 19, :column 1, :end-line 19, :end-column 19, :meta {:file "/Users/swilliam/code/parinfer/src/parinfer/format/infer.cljc", :line 19, :column 6, :end-line 19, :end-column 19}, :doc "An initial state of our running state."}, block-delim-trail {:protocol-inline nil, :meta {:file "/Users/swilliam/code/parinfer/src/parinfer/format/infer.cljc", :line 116, :column 7, :end-line 116, :end-column 24, :arglists (quote ([{:keys [delim-trail line-no cursor-line cursor-x cursor-in-comment?], :as state}])), :doc "The presence of the cursor can block the removal of some part of the delim trail."}, :name parinfer.format.infer/block-delim-trail, :variadic false, :file "src/parinfer/format/infer.cljc", :end-column 24, :method-params ([p__37561]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 116, :end-line 116, :max-fixed-arity 1, :fn-var true, :arglists (quote ([{:keys [delim-trail line-no cursor-line cursor-x cursor-in-comment?], :as state}])), :doc "The presence of the cursor can block the removal of some part of the delim trail."}, process-text {:protocol-inline nil, :meta {:file "/Users/swilliam/code/parinfer/src/parinfer/format/infer.cljc", :line 280, :column 7, :end-line 280, :end-column 19, :arglists (quote ([text] [state text])), :doc "Update the state by processing the given text.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([text] [state text]), :arglists ([text] [state text]), :arglists-meta (nil nil)}}, :name parinfer.format.infer/process-text, :variadic false, :file "src/parinfer/format/infer.cljc", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([text] [state text]), :arglists ([text] [state text]), :arglists-meta (nil nil)}, :method-params ([text] [state text]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 280, :end-line 280, :max-fixed-arity 2, :fn-var true, :arglists ([text] [state text]), :doc "Update the state by processing the given text."}, process-indent {:protocol-inline nil, :meta {:file "/Users/swilliam/code/parinfer/src/parinfer/format/infer.cljc", :line 212, :column 7, :end-line 212, :end-column 21, :arglists (quote ([{:keys [stack track-indent? lines line-no x-pos ch], :as state}])), :doc "Update the state by handling a possible indentation trigger.\n\n  Example:\n  \n  (defn foo [a b\n     ret           ;; <---  When we process `r`, we detect indentation, then\n                   ;;       we start backtracking to insert closing delimiters on a previous line.\n\n\n  (defn foo [a b]\n     )             ;; <---  If a line starts with a closing delimiter, it is not\n                   ;;       considered an indentation trigger.  In fact, we skip\n                   ;;       the character completely, removing it from the line.\n  "}, :name parinfer.format.infer/process-indent, :variadic false, :file "src/parinfer/format/infer.cljc", :end-column 21, :method-params ([p__37598]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 212, :end-line 212, :max-fixed-arity 1, :fn-var true, :arglists (quote ([{:keys [stack track-indent? lines line-no x-pos ch], :as state}])), :doc "Update the state by handling a possible indentation trigger.\n\n  Example:\n  \n  (defn foo [a b\n     ret           ;; <---  When we process `r`, we detect indentation, then\n                   ;;       we start backtracking to insert closing delimiters on a previous line.\n\n\n  (defn foo [a b]\n     )             ;; <---  If a line starts with a closing delimiter, it is not\n                   ;;       considered an indentation trigger.  In fact, we skip\n                   ;;       the character completely, removing it from the line.\n  "}, update-line {:protocol-inline nil, :meta {:file "/Users/swilliam/code/parinfer/src/parinfer/format/infer.cljc", :line 238, :column 7, :end-line 238, :end-column 18, :arglists (quote ([{:keys [ch line-no], :as state}])), :doc "Update the state by addding processed character to the line."}, :name parinfer.format.infer/update-line, :variadic false, :file "src/parinfer/format/infer.cljc", :end-column 18, :method-params ([p__37605]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 238, :end-line 238, :max-fixed-arity 1, :fn-var true, :arglists (quote ([{:keys [ch line-no], :as state}])), :doc "Update the state by addding processed character to the line."}, close-delims {:protocol-inline nil, :meta {:file "/Users/swilliam/code/parinfer/src/parinfer/format/infer.cljc", :line 30, :column 7, :end-line 30, :end-column 19, :arglists (quote ([state] [state indent-x])), :doc "Update the state by inferring closing delimiters.\n  Do this by using the given indentation level.\n  \n  Example:\n  \n  (defn foo [a b\n     ret           ;; <---  When we process `r`, we detect indentation, then...\n\n  (defn foo [a b]  ;; <---  ... we insert a `]` after `b` since `[` is after `r` on the x-axis.\n     ret           ;; <---  A `)` is inserted after `ret` if no further indented lines found.\n  ", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([state] [state indent-x]), :arglists ([state] [state indent-x]), :arglists-meta (nil nil)}}, :name parinfer.format.infer/close-delims, :variadic false, :file "src/parinfer/format/infer.cljc", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([state] [state indent-x]), :arglists ([state] [state indent-x]), :arglists-meta (nil nil)}, :method-params ([state] [state indent-x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 30, :end-line 30, :max-fixed-arity 2, :fn-var true, :arglists ([state] [state indent-x]), :doc "Update the state by inferring closing delimiters.\n  Do this by using the given indentation level.\n  \n  Example:\n  \n  (defn foo [a b\n     ret           ;; <---  When we process `r`, we detect indentation, then...\n\n  (defn foo [a b]  ;; <---  ... we insert a `]` after `b` since `[` is after `r` on the x-axis.\n     ret           ;; <---  A `)` is inserted after `ret` if no further indented lines found.\n  "}, update-insertion-pt {:protocol-inline nil, :meta {:file "/Users/swilliam/code/parinfer/src/parinfer/format/infer.cljc", :line 172, :column 7, :end-line 172, :end-column 26, :arglists (quote ([{:keys [track-indent? cursor-line lines line-no stack x-pos ch], :as state}])), :doc "Update the state's trailing delimiter insertion point as we scan the line.\n  \n  Example:\n  \n  (defn foo [a b] ret)\n  ^^^^^ ^^^ ^^ ^  ^^^\n                    |\n                    +-- final insertion point candidate\n\n  Special rules allow the user to freely position the trailing\n  delimiters while editing a line.\n\n  "}, :name parinfer.format.infer/update-insertion-pt, :variadic false, :file "src/parinfer/format/infer.cljc", :end-column 26, :method-params ([p__37591]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 172, :end-line 172, :max-fixed-arity 1, :fn-var true, :arglists (quote ([{:keys [track-indent? cursor-line lines line-no stack x-pos ch], :as state}])), :doc "Update the state's trailing delimiter insertion point as we scan the line.\n  \n  Example:\n  \n  (defn foo [a b] ret)\n  ^^^^^ ^^^ ^^ ^  ^^^\n                    |\n                    +-- final insertion point candidate\n\n  Special rules allow the user to freely position the trailing\n  delimiters while editing a line.\n\n  "}, remove-delim-trail {:protocol-inline nil, :meta {:file "/Users/swilliam/code/parinfer/src/parinfer/format/infer.cljc", :line 130, :column 7, :end-line 130, :end-column 25, :arglists (quote ([{:keys [delim-trail insert line-no lines backup stack], :as state}])), :doc "Update the state by removing our marked delim trail.\n  We remove the delims from the appropriate line of text,\n  while also restoring their matching delims onto the stack.\n\n  Example:\n  \n  (foo (+ 2 3) [(bar)] )    ;; a potential comment\n  ^            ^^   ^^^^\n  |            |     |\n  |____________|     +-- Remove these from the text.\n         |\n         +-- Restore these onto the delim stack.\n             (fyi, we originally popped them off to validate\n              the closing delims. now we need them back to\n              infer closing delims for indented lines.)\n  "}, :name parinfer.format.infer/remove-delim-trail, :variadic false, :file "src/parinfer/format/infer.cljc", :end-column 25, :method-params ([p__37576]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 130, :end-line 130, :max-fixed-arity 1, :fn-var true, :arglists (quote ([{:keys [delim-trail insert line-no lines backup stack], :as state}])), :doc "Update the state by removing our marked delim trail.\n  We remove the delims from the appropriate line of text,\n  while also restoring their matching delims onto the stack.\n\n  Example:\n  \n  (foo (+ 2 3) [(bar)] )    ;; a potential comment\n  ^            ^^   ^^^^\n  |            |     |\n  |____________|     +-- Remove these from the text.\n         |\n         +-- Restore these onto the delim stack.\n             (fyi, we originally popped them off to validate\n              the closing delims. now we need them back to\n              infer closing delims for indented lines.)\n  "}, process-char* {:protocol-inline nil, :meta {:file "/Users/swilliam/code/parinfer/src/parinfer/format/infer.cljc", :line 243, :column 7, :end-line 243, :end-column 20, :arglists (quote ([state]))}, :name parinfer.format.infer/process-char*, :variadic false, :file "src/parinfer/format/infer.cljc", :end-column 20, :method-params ([state]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 243, :end-line 243, :max-fixed-arity 1, :fn-var true, :arglists (quote ([state]))}, update-delim-trail {:protocol-inline nil, :meta {:file "/Users/swilliam/code/parinfer/src/parinfer/format/infer.cljc", :line 63, :column 7, :end-line 63, :end-column 25, :arglists (quote ([{:keys [stack delim-trail backup x-pos ch cursor-line line-no cursor-x cursor-in-comment?], :as state}])), :doc "Update the state's delim trail as we scan across a line.\n  We eventually remove the delim trail since we indented\n  content below can cause the delims to move.\n\n  Example:\n  \n  (foo (+ 2 3) [(bar)] )    ;; a potential comment\n                    ^^^^\n                     |\n                     +-- trailing delims that we will remove\n                          (notice whitespace will also be removed)\n  "}, :name parinfer.format.infer/update-delim-trail, :variadic false, :file "src/parinfer/format/infer.cljc", :end-column 25, :method-params ([p__37554]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 63, :end-line 63, :max-fixed-arity 1, :fn-var true, :arglists (quote ([{:keys [stack delim-trail backup x-pos ch cursor-line line-no cursor-x cursor-in-comment?], :as state}])), :doc "Update the state's delim trail as we scan across a line.\n  We eventually remove the delim trail since we indented\n  content below can cause the delims to move.\n\n  Example:\n  \n  (foo (+ 2 3) [(bar)] )    ;; a potential comment\n                    ^^^^\n                     |\n                     +-- trailing delims that we will remove\n                          (notice whitespace will also be removed)\n  "}, process-line {:protocol-inline nil, :meta {:file "/Users/swilliam/code/parinfer/src/parinfer/format/infer.cljc", :line 261, :column 7, :end-line 261, :end-column 19, :arglists (quote ([line] [{:keys [stack lines line-no cursor-line], :as state} line])), :doc "Update the state by processing the given line of text.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([line] [{:keys [stack lines line-no cursor-line], :as state} line]), :arglists ([line] [{:keys [stack lines line-no cursor-line], :as state} line]), :arglists-meta (nil nil)}}, :name parinfer.format.infer/process-line, :variadic false, :file "src/parinfer/format/infer.cljc", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([line] [{:keys [stack lines line-no cursor-line], :as state} line]), :arglists ([line] [{:keys [stack lines line-no cursor-line], :as state} line]), :arglists-meta (nil nil)}, :method-params ([line] [{:keys [stack lines line-no cursor-line], :as state} line]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 261, :end-line 261, :max-fixed-arity 2, :fn-var true, :arglists ([line] [{:keys [stack lines line-no cursor-line], :as state} line]), :doc "Update the state by processing the given line of text."}, process-char {:protocol-inline nil, :meta {:file "/Users/swilliam/code/parinfer/src/parinfer/format/infer.cljc", :line 252, :column 7, :end-line 252, :end-column 19, :arglists (quote ([{:keys [lines line-no], :as state} ch])), :doc "Update the state by processing the given character and its position."}, :name parinfer.format.infer/process-char, :variadic false, :file "src/parinfer/format/infer.cljc", :end-column 19, :method-params ([p__37610 ch]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 252, :end-line 252, :max-fixed-arity 2, :fn-var true, :arglists (quote ([{:keys [lines line-no], :as state} ch])), :doc "Update the state by processing the given character and its position."}, format-text {:protocol-inline nil, :meta {:file "/Users/swilliam/code/parinfer/src/parinfer/format/infer.cljc", :line 297, :column 7, :end-line 297, :end-column 18, :arglists (quote ([text] [state text])), :doc "Format the given text by repositioning any trailing closing delimiters based on indentation.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([text] [state text]), :arglists ([text] [state text]), :arglists-meta (nil nil)}}, :name parinfer.format.infer/format-text, :variadic false, :file "src/parinfer/format/infer.cljc", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([text] [state text]), :arglists ([text] [state text]), :arglists-meta (nil nil)}, :method-params ([text] [state text]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 297, :end-line 297, :max-fixed-arity 2, :fn-var true, :arglists ([text] [state text]), :doc "Format the given text by repositioning any trailing closing delimiters based on indentation."}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:cursor-line :backup :insert :else :process? :x-pos :cursor-x :start :lines :ch :track-indent? :line-no :stack :delim-trail :removed-delims :end :cursor-in-comment?}, :order [:lines :line-no :track-indent? :delim-trail :insert :stack :backup :start :end :x-pos :ch :cursor-line :cursor-x :cursor-in-comment? :else :removed-delims :process?]}, :doc "Corrects parens based on indentation.\n  (used while editing a file)"}